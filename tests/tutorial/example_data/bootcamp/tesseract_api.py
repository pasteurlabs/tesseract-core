# Copyright 2025 Pasteur Labs. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Tesseract API module for bootcamp
# Generated by tesseract 0.8.6.dev6+g5b4107c.d20250505 on 2025-05-08T15:15:41.801365


import json
import os

from pydantic import BaseModel, Field

from tesseract_core.runtime import Array, Differentiable, Int32

#
# Schemas
#


class InputSchema(BaseModel):
    message: Differentiable[Array[(None,), Int32]] = Field(
        description="An arbitrary array."
    )


class OutputSchema(BaseModel):
    decoded_message: str = Field(description="Decoded Message.")


#
# Required endpoints
#


def apply(inputs: InputSchema) -> OutputSchema:
    array = inputs.message

    dirname = os.path.dirname(__file__)
    message_key = os.path.join(dirname, "message_key.json")

    # If key exists, use it:
    if os.path.exists(message_key):
        # check parameters
        with open(message_key) as file:
            key = json.load(file)
            array += key["key"]

    chars = [chr(n + 96) if n > 0 else " " for n in array]
    return OutputSchema(decoded_message="".join(chars))


#
# Optional endpoints
#

# import numpy as np

# def jacobian(inputs: InputSchema, jac_inputs: set[str], jac_outputs: set[str]):
#     return {}

# def jacobian_vector_product(
#     inputs: InputSchema,
#     jvp_inputs: set[str],
#     jvp_outputs: set[str],
#     tangent_vector: dict[str, np.typing.ArrayLike]
# ) -> dict[str, np.typing.ArrayLike]:
#     return {}

# def vector_jacobian_product(
#     inputs: InputSchema,
#     vjp_inputs: set[str],
#     vjp_outputs: set[str],
#     cotangent_vector: dict[str, np.typing.ArrayLike]
# ) -> dict[str, np.typing.ArrayLike]:
#     return {}

# def abstract_eval(abstract_inputs):
#     return {}
