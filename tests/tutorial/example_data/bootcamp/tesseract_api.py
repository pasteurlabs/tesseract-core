# Copyright 2025 Pasteur Labs. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Tesseract API module for bootcamp
# Generated by tesseract 0.8.6.dev6+g5b4107c.d20250505 on 2025-05-08T15:15:41.801365


import json
import os

from pydantic import BaseModel, Field

from tesseract_core.runtime import Array, Int32

#
# Schemas
#


class InputSchema(BaseModel):
    ciphertext: Array[(None,), Int32] = Field(description="The ciphered message.")


class OutputSchema(BaseModel):
    message: str = Field(description="Decoded Message")


#
# Required endpoints
#


def apply(inputs: InputSchema) -> OutputSchema:
    array = inputs.ciphertext

    dirname = os.path.dirname(__file__)
    message_key = os.path.join(dirname, "message_key.json")

    # If key exists, use it:
    if os.path.exists(message_key):
        # check parameters
        with open(message_key) as file:
            # If key is same length as array, use it:
            key = json.load(file)
            if len(key["key"]) == len(array):
                array += key["key"]
            else:
                raise ValueError(
                    f"Key length {len(key['key'])} does not match ciphertext length {len(array)}."
                )

    chars = [chr(n + 96) if n > 0 else " " for n in array]
    return OutputSchema(message="".join(chars))


#
# Optional endpoints
#

# import numpy as np

# def jacobian(inputs: InputSchema, jac_inputs: set[str], jac_outputs: set[str]):
#     return {}

# def jacobian_vector_product(
#     inputs: InputSchema,
#     jvp_inputs: set[str],
#     jvp_outputs: set[str],
#     tangent_vector: dict[str, np.typing.ArrayLike]
# ) -> dict[str, np.typing.ArrayLike]:
#     return {}

# def vector_jacobian_product(
#     inputs: InputSchema,
#     vjp_inputs: set[str],
#     vjp_outputs: set[str],
#     cotangent_vector: dict[str, np.typing.ArrayLike]
# ) -> dict[str, np.typing.ArrayLike]:
#     return {}

# def abstract_eval(abstract_inputs):
#     return {}
