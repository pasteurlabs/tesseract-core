# Setting up the `tesseract_api.py` file for the Julia surrogate
Right after ```$ tesseract init ```, the `tesseract_api.py` template looks like follows:

<details>
  <summary><b>Click to expand the code</b></summary>

```Python
# Tesseract API module for check_tesseract
# Generated by tesseract 0.3.0+6.g9ece6f8 on 2024-08-22T09:00:59.002494

from pydantic import BaseModel

#
# Schemata
#

class InputSchema(BaseModel):
    pass


class OutputSchema(BaseModel):
    pass


#
# Required endpoints
#

def apply(inputs: InputSchema) -> OutputSchema:
    return OutputSchema()


#
# Optional endpoints
#

# def jacobian(inputs: InputSchema, jac_inputs: set[str], jac_outputs: set[str]):
#     return {}

# def hessian(inputs: InputSchema, hess_inputs: set[str], hess_outputs: set[str]):
#     return {}

# def jacobian_vector_product(inputs: InputSchema, jvp_inputs: set[str], jvp_outputs: set[str], tangent_vector):
#     return {}

# def vector_jacobian_product(inputs: InputSchema, vjp_inputs: set[str], vjp_outputs: set[str], cotangent_vector):
#     return {}

# def abstract_eval(abstract_inputs):
#     return {}
```

</details>

And after filling this out correctly, we have
<details>
  <summary><b>Click to expand the code</b></summary>

```Python
import juliacall
import numpy as np
from pydantic import BaseModel, Field
from typing import Optional
from tesseract_runtime import Differentiable, Float64, ShapeDType, Array

#
# Schemata
#

# initialize julia environment
jl = juliacall.newmodule("julia_surrogate")
jl.seval("using Pkg")
jl.seval('Pkg.activate("StressSurrogate")')
jl.seval("using StressSurrogate")

# warm up (jit compile) julia functions
jl.StressSurrogate.eval_forward(np.array([0.5, 0.5, 0.15, 45.0]))
jl.StressSurrogate.eval_gradient(np.array([0.5, 0.5, 0.15, 45.0]))


class InputSchema(BaseModel):
    xc: Differentiable[Float64] = Field(
        description="Ellipse center x coordinate.", default=0.5
    )
    yc: Differentiable[Float64] = Field(
        description="Ellipse center y coordinate.", default=0.5
    )
    axis_x: Differentiable[Float64] = Field(
        description="Axis skew in x direction.", default=0.15
    )
    theta: Differentiable[Float64] = Field(
        description="Ellipse angle with origin [degrees].", default=45.0
    )
    return_force_components: bool = Field(
        description="Whether to return force components for apply.",
        default=False,
    )
    return_stress_components: bool = Field(
        description="Whether to return von-mises stress for apply.",
        default=False,
    )

class OutputSchema(BaseModel):
    mean_stress: Differentiable[Float64] = Field(
        description="The maximum stress along the (x=1,y=1) boundaries."
    )
    fx: Optional[Array[(2601,), " float64"]] = Field(description="Force x component.")
    fy: Optional[Array[(2601,), " float64"]] = Field(description="Force y component.")
    s: Optional[Array[(2601,), " float64"]] = Field(description="Von-mises stress.")

#
# Required endpoints
#


def apply(inputs: InputSchema) -> OutputSchema:
    x = np.array([inputs.xc, inputs.yc, inputs.axis_x, inputs.theta])
    load_field = jl.StressSurrogate.generate_field(x)
    stress_field = jl.StressSurrogate.eval_surrogate(load_field)
    mean_stress = jl.StressSurrogate.calc_mean_stress_from_field(stress_field)

    if inputs.return_force_components:
        load_field_return = np.reshape(load_field, (2601,2), order="F")
        fx = load_field_return[:,0]
        fy = load_field_return[:,1]
    else:
        fx = None
        fy = None

    if inputs.return_stress_components:
        s = stress_field
    else:
        s = None

    return OutputSchema(
        mean_stress=mean_stress,
        fx=fx,
        fy=fy,
        s=s
    )


#
# Optional endpoints
#
def abstract_eval(abstract_inputs):
    return {"mean_stress": ShapeDType(shape=(), dtype="float64")}

def jacobian(inputs: InputSchema, jac_inputs: set[str], jac_outputs: set[str]):
    assert set(jac_inputs) == set(["xc", "yc", "axis_x", "theta"])
    x = np.array([inputs.xc, inputs.yc, inputs.axis_x, inputs.theta])
    grad = jl.StressSurrogate.eval_gradient(x)
    return {
        "xc": {"mean_stress": grad[0]},
        "yc": {"mean_stress": grad[1]},
        "axis_x": {"mean_stress": grad[2]},
        "theta": {"mean_stress": grad[3]},
    }

```
</details>

At this point there are many things to address; we proceed step by step as illustrated below.

## Loading the Julia surrogate model package inside Python

The first step is to make sure that the functions related to the Julia surrogate model are callable inside the Python environment. The script below (part of the `tesseract_api.py`) sets up a Julia environment using `juliacall`, creats a new Julia module (`julia_surrogate`) to isolate the Julia code and then activates and loads the Julia surrogate package `StressSurrogate`. Finally, it warms up the key functions from the package.

```Python
import juliacall

# initialize julia environment
jl = juliacall.newmodule("julia_surrogate")
jl.seval("using Pkg")
jl.seval('Pkg.activate("StressSurrogate")')
jl.seval("using StressSurrogate")

# warm up (jit compile) julia functions
jl.StressSurrogate.eval_forward(np.array([0.5, 0.5, 0.15, 45.0]))
jl.StressSurrogate.eval_gradient(np.array([0.5, 0.5, 0.15, 45.0]))
```
## Setting up the `apply` function

The step of setting up the apply function must always be present with no exception. Here, we define the operations we want the tesseeract to implement. In this specific case, we want to obtain the mean stress field as a function of user-defined ellipse parameters. In addition, if needed, we can also obtain the loading field and resulting stress field over the whole domain.
The script below makes use of the previously discussed functions `generate_field`, `eval_surrogate` and `calc_mean_stress_from_field` (see the description of the Julia surrogate). These functions, when composed, return the mean stress at the free boundaries as a function of the input parameters that are stored inside `inputs` ($ p = \{\text{inputs.xc}, \text{inputs.yc}, \text{inputs.axis\_x}, \text{inputs.theta} \} $). In addition, `inputs` also holds the boolean value of `return_force_components` and `return_stress_component` to optionally return the forcing field and stress field respectively.

```Python
#
# Required endpoints
#
def apply(inputs: InputSchema) -> OutputSchema:
    x = np.array([inputs.xc, inputs.yc, inputs.axis_x, inputs.theta])
    load_field = jl.StressSurrogate.generate_field(x)
    stress_field = jl.StressSurrogate.eval_surrogate(load_field)
    mean_stress = jl.StressSurrogate.calc_mean_stress_from_field(stress_field)

    if inputs.return_force_components:
        load_field_return = np.reshape(load_field, (2601,2), order="F")
        fx = load_field_return[:,0]
        fy = load_field_return[:,1]
    else:
        fx = None
        fy = None

    if inputs.return_stress_components:
        s = stress_field
    else:
        s = None

    return OutputSchema(
        mean_stress=mean_stress,
        fx=fx,
        fy=fy,
        s=s
    )
```
In the above script, the function signature `def apply(inputs: InputSchema) -> OutputSchema:` include _type hints_ indicating that the `inputs` should be of type `InputSchema` and the return value of function to be of type `OutputSchema`. We say more about this below.

## Setting up `InputSchema` and `OutputSchema` classes

The classes `InputSchema` and `OutputSchema` define the structure, type, and validation rules for the input and output data in a standardized way using the `pydantic` library. This ensures that any data passed to or returned by `apply` functions adheres to a predefined schema.

The `InputSchema` class builds on top of `BasedModel` dataclass from `pydantic`. We configure this class based on the user input parameters and their format. For example, the input to the apply function might be a dictionary like `{"xc": 0.5, "yc": 0.5, "axis_x": 0.15, "theta": 45.0, "return_force_components": False, "return_stress_component": True}`. `InputSchema` will parse and validate this dictionary, ensuring that the input values are correctly structured for the `apply` function. If any of the input value is missing, it will assign the default values speciefied in the corresponding `Field`.

```Python
class InputSchema(BaseModel):
    xc: Differentiable[Float64] = Field(
        description="Ellipse center x coordinate.", default=0.5
    )
    yc: Differentiable[Float64] = Field(
        description="Ellipse center y coordinate.", default=0.5
    )
    axis_x: Differentiable[Float64] = Field(
        description="Axis skew in x direction.", default=0.15
    )
    theta: Differentiable[Float64] = Field(
        description="Ellipse angle with origin [degrees].", default=45.0
    )
    return_force_components: bool = Field(
        description="Whether to return force components for apply.",
        default=False,
    )
    return_stress_components: bool = Field(
        description="Whether to return von-mises stress for apply.",
        default=False,
    )
```

Similarly, the `OutputSchema` class is configured considering type and format of the data returned by `apply`. In our case, `apply` returns the mean stress at the free boundaries and, optionally, the loading and stress fields. As a result, `OutputSchema` looks as follows.

```Python
class OutputSchema(BaseModel):
    mean_stress: Differentiable[Float64] = Field(
        description="The maximum stress along the (x=1,y=1) boundaries."
    )
    fx: Optional[Array[(2601,), " float64"]] = Field(description="Force x component.")
    fy: Optional[Array[(2601,), " float64"]] = Field(description="Force y component.")
    s: Optional[Array[(2601,), " float64"]] = Field(description="Von-mises stress.")
```

> **_NOTE:_**  It is not mandatory to know the size of returned arrays. If array sizes are not known beforehand, `None` should be speciefied (e.g. `fx: Optional[Array[(None,), " float64"]]`).


## Setting up `jacobian` endpoint

The function `eval_gradient` for the Julia surrogate evaluates the gradient (or Jacobian for a multiscalar output) of the quantity of interest with respect to the input ellipse paramters. In order to make use of these gradients for, e.g., optimization purposes, users must invoke the <span class="product">Tesseract</span>'s `jacobian` endpoint.

In the script below, the function signature has `jac_inputs: set[str]` and `jac_outputs: set[str]` in addition to `inputs: InputSchema`. The Jacobian ($J = \frac{\partial g_i}{\partial p_j}$) is evaluated such that output vector $\mathbf{g}$ is specified in `jac_outputs: set[str]` and input vector $\mathbf{p}$ is specified in `jac_inputs: set[str]` and the Jacobian $J$ is evaluated at `inputs: InputSchema`.

In the current setting, the output vector is the mean stress at free boundary (a scalar) and `jac_inputs` are forced to be same as `Inputs` in order to obtain the gradient of the objective function with respect to the ellipse parameters ($\frac{d \mathcal{L}}{d\mathbf{p}}$) from the same endpoint of `jacobian`. The returned value is a dictionary containing the derivatives of the mean stress with respect to to each ellipse parameter.

```Python
def jacobian(inputs: InputSchema, jac_inputs: set[str], jac_outputs: set[str]):
    assert set(jac_inputs) == set(["xc", "yc", "axis_x", "theta"])
    x = np.array([inputs.xc, inputs.yc, inputs.axis_x, inputs.theta])
    grad = jl.StressSurrogate.eval_gradient(x)
    return {
        "xc": {"mean_stress": grad[0]},
        "yc": {"mean_stress": grad[1]},
        "axis_x": {"mean_stress": grad[2]},
        "theta": {"mean_stress": grad[3]},
    }
```

> **_NOTE:_** Implementing the jacobian endpoint enables optimization with the Tesseracted surrogate. See the [optimization tutorial](../../optimization_with_surrogates/linear_ellipse_optimization.md) to see how a jacobian endpoint is used in an application.
