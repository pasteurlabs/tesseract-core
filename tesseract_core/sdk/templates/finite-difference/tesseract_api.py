# Copyright 2025 Pasteur Labs. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Tesseract API module for {{name}}
# Generated by tesseract {{version}} on {{timestamp}}

from typing import Any, Literal

from pydantic import BaseModel

from tesseract_core.runtime import Differentiable, Field, Float32
from tesseract_core.runtime.tree_transforms import bump_at_path, flatten_with_paths

#
# Schemata
#


class InputSchema(BaseModel):
    example: Differentiable[Float32]
    eps: float = Field(default=1e-3)
    mode: Literal["forward", "reverse", "central"] = Field(default="central")


class OutputSchema(BaseModel):
    example: Differentiable[Float32]


#
# Required endpoints
#


def apply(inputs: InputSchema) -> OutputSchema:
    return {"example": inputs.example}


#
# Jax-handled AD endpoints (no need to modify)
#


def jacobian(
    inputs: InputSchema,
    jac_inputs: set[str],
    jac_outputs: set[str],
):
    jacobian = {dy: {dx: 1 for dx in jac_inputs} for dy in jac_outputs}
    return jacobian


def jacobian_vector_product(
    inputs: InputSchema,
    jvp_inputs: set[str],
    jvp_outputs: set[str],
    tangent_vector: dict[str, Any],
):
    tangent_norm = sum((ele**2).sum() for ele in tangent_vector) ** 0.5

    if inputs.mode == "central":
        denom = 2 * inputs.eps
    else:
        denom = inputs.eps

    if inputs.mode == "reverse":
        inputs_up = inputs
    else:
        bump_up_vector = {
            k: inputs.eps * v / tangent_norm / denom for k, v in tangent_vector.items()
        }
        inputs_up = bump_at_path(inputs, bump_up_vector, jvp_inputs)

    if inputs.mode != "forward":
        inputs_down = inputs
    else:
        bump_down_vector = {
            k: -inputs.eps * v / tangent_norm / denom for k, v in tangent_vector.items()
        }
        inputs_down = bump_at_path(inputs, bump_down_vector, jvp_inputs)

    filtered_up = flatten_with_paths(apply(inputs_up), include_paths=jvp_outputs)
    filtered_down = flatten_with_paths(apply(inputs_down), include_paths=jvp_outputs)

    return (filtered_up - filtered_down) / inputs.eps


def vector_jacobian_product(
    inputs: InputSchema,
    vjp_inputs: set[str],
    vjp_outputs: set[str],
    cotangent_vector: dict[str, Any],
):
    return None
